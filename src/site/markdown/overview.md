# Approach overview

## Model serialization in source code

We advocate for a strong coupling between model and source-code, to give architects and developers a way to both interact during the whole development cycle. PAMELA is an annotation-based Java modeling framework providing a smooth integration between model and code, without code generation nor externalized model serialization. The idea is to avoid separation between modeling and code to facilitate consistency management and avoid round-tripping issues.

To do so, we argue that source code is the right artefact to encode the model with metadata information stored in tagged code. This requires an annotation-enabled language. Such language supports the attribute-oriented programming if its grammar allows adding custom declarative tags to annotate standard program elements. Java programming language from version 1.5 is a good candidate with the support of annotations.

Following figure shows PAMELA approach for storing model in source code. The model is inlined in many source code files, with a set of annotations covering PAMELA metamodel as presented in the next subsection.
    
![PamelaVisionV2](https://support.openflexo.org/images/components/pamela/PamelaVisionV2.png)

## PAMELA use process
    
Coupling model and code into the same artefact open new ways of programming. The classical way relies on 
*programmers* that produce code reusing pre-existing modeling concepts. These concepts are implemented 
by \emph{modelers} that provides the right annotations the programmers use. This is, for instance, the 
process followed by JEE developers reusing JEE specific annotations. The evolution rhythm between models 
and code is low. This programming way is still possible with PAMELA, but we allow the ability to reach a 
high evolution rhythm when the programmer becomes also the modeler. In fact, when a pattern, an abstraction, 
a generalization is identified by the programmer, s/he can use PAMELA to develop and capitalize on this 
abstraction by increasing PAMELA metamodel. 

The developed metamodels are implemented by annotations that relies on Java/JVM entities and mechanisms. They include consistency checking that constrains their use and help the programmer. We have experimented their use with setter/getter to define POJO entities, with traits to implement multiple inheritance or roles and rules to set security rules on classes.

Our experience shows that introducing and reusing new concepts (1) reduce the size of the code, (2) reduce the risk of errors and (3) improve the code structure. The cycle of development between the model and the code can then be drastically reduced, leading to what we call *continuous modeling*.

The code size is reduced because abstractions factorize the recognize pattern and the previous code is replaced by the use of the abstraction at the right place. This also reduce the risk since the previous code is now generated by the PAMELA framework with all the required checks. And finally, the code structure is improved since it matches the way the programmer conceptualizes (models) her/his code. 

## PAMELA metamodel

PAMELA metamodel is presented in following figure.
This metamodel is classical and reflects a common class diagram vision such as in UML. 

![PamelaMetaModel](https://support.openflexo.org/images/components/pamela/PamelaMetaModel.png)

- A `PAMELAModel` is defined as a set of references to `ModelEntity`.
- A `ModelEntity` reflects a concept and is encoded in a java `interface`. PAMELA metamodel allows multiple inheritance: thus `ModelEntity` may define a set of parent entities. A `ModelEntity` also defines some properties, encoded as `ModelProperty`. Note that reification of `ModelEntity` is performed in a java `interface` (and not a class), which only defines API whithout any implementation for methods. A partially implemented `abstract` java `class` may be defined as partial base implementation (conform to implemented interface).
- A `ModelProperty` is identified by a name, a cardinality (simple or multiple) and a type, which can be a reference to another `ModelEntity`, or a Java type (a primitive or an arbitrary complex Java type). Depending on its cardinality, a `ModelProperty` is bound to a set of methods reflecting use of property.
    - A *read-only single property* will define read-access of its value using a *getter* (a java method defined in java interface taking no argument and returning desired value).
    - A *read-write single property* will define a *getter* and a *setter* (a java method taking value to be set as unique argument)
    - A *read-write multiple property* will define a *getter*, a *adder* (a java method taking value to be added as unique argument), a *remover* (a java method taking value to be removed as unique argument), and may define additional methods for extended features such as reindexing for example.

A strong interest of the approach is that the model is encoded in java, and must be compiled. It forces the java compiler to perform required checks for a PAMELA model encoded in a strong typed program. Execution semantics of model is fully compatible with Java semantics. Many validation rules are automatically performed through classical java compilation, independently of underlying PAMELA execution semantics.


[<< Approach overview](./overview.html)  [A basic example >>](./example.html)

 

    
  
